name: Deploy Code to Production

on:
  push:
    branches:
      - master
  workflow_dispatch:

env:
  NODE_ENV: production
  AWS_REGION: eu-west-3

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Pulumi
        run: |
          mkdir -p ~/.pulumi/stacks
          bun x pulumi login file://~/.pulumi/stacks

      - name: Get Infrastructure Outputs
        id: get-infra
        run: |
          # Get worker outputs
          WORKER_REPO=$(bun x pulumi stack output ecrRepoUrl -s worker-prod 2>/dev/null || echo "")
          WORKER_LAMBDA=$(bun x pulumi stack output workerLambdaName -s worker-prod 2>/dev/null || echo "")
          WORKER_QUEUE_URL=$(bun x pulumi stack output queueUrl -s worker-prod 2>/dev/null || echo "")

          if [[ -z "$WORKER_REPO" ]] || [[ -z "$WORKER_LAMBDA" ]]; then
            echo "‚ùå Could not get worker infrastructure outputs. Is infrastructure deployed?"
            exit 1
          fi
          echo "worker_repo=${WORKER_REPO}" >> $GITHUB_OUTPUT
          echo "worker_lambda=${WORKER_LAMBDA}" >> $GITHUB_OUTPUT
          echo "worker_queue_url=${WORKER_QUEUE_URL}" >> $GITHUB_OUTPUT

          # Get backend outputs
          BACKEND_REPO=$(bun x pulumi stack output ecrRepoUrl -s lambda-prod 2>/dev/null || echo "")
          BACKEND_LAMBDA=$(bun x pulumi stack output apiLambdaName -s lambda-prod 2>/dev/null || echo "")
          API_URL=$(bun x pulumi stack output apiUrl -s lambda-prod 2>/dev/null || echo "")

          if [[ -z "$BACKEND_REPO" ]] || [[ -z "$BACKEND_LAMBDA" ]]; then
            echo "‚ùå Could not get backend infrastructure outputs. Is infrastructure deployed?"
            exit 1
          fi
          echo "backend_repo=${BACKEND_REPO}" >> $GITHUB_OUTPUT
          echo "backend_lambda=${BACKEND_LAMBDA}" >> $GITHUB_OUTPUT
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT

      - name: Build and Deploy Worker Lambda
        run: |
          # Build Docker image
          docker build -t worker-prod -f .docker/Dockerfile.worker .

          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ steps.get-infra.outputs.worker_repo }}

          # Tag and push
          docker tag worker-prod ${{ steps.get-infra.outputs.worker_repo }}:prod
          docker push ${{ steps.get-infra.outputs.worker_repo }}:prod

          # Update Lambda function
          aws lambda update-function-code \
            --function-name ${{ steps.get-infra.outputs.worker_lambda }} \
            --image-uri ${{ steps.get-infra.outputs.worker_repo }}:prod \
            --region ${{ env.AWS_REGION }} \
            --wait

          echo "‚úÖ Worker Lambda deployed successfully"

      - name: Update Worker Lambda Environment Variables
        run: |
          # Create environment variables JSON file
          cat > /tmp/worker-lambda-env.json <<EOF
          {
            "Variables": {
              "DATABASE_URL": "${{ secrets.DATABASE_URL }}",
              "LOG_LEVEL": "${{ secrets.LOG_LEVEL }}",
              "NODE_ENV": "production",
              "WORKER_MODE": "lambda",
              "SQS_QUEUE_URL": "${{ steps.get-infra.outputs.worker_queue_url }}"
            }
          }
          EOF

          # Update Lambda function environment variables with secrets
          aws lambda update-function-configuration \
            --function-name ${{ steps.get-infra.outputs.worker_lambda }} \
            --environment file:///tmp/worker-lambda-env.json \
            --region ${{ env.AWS_REGION }} \
            --wait

          echo "‚úÖ Worker Lambda environment variables updated successfully"

      - name: Build and Deploy Backend Lambda
        run: |
          # Build Docker image
          docker build -t api-prod -f .docker/Dockerfile.lambda .

          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ steps.get-infra.outputs.backend_repo }}

          # Tag and push
          docker tag api-prod ${{ steps.get-infra.outputs.backend_repo }}:prod
          docker push ${{ steps.get-infra.outputs.backend_repo }}:prod

          # Update Lambda function
          aws lambda update-function-code \
            --function-name ${{ steps.get-infra.outputs.backend_lambda }} \
            --image-uri ${{ steps.get-infra.outputs.backend_repo }}:prod \
            --region ${{ env.AWS_REGION }} \
            --wait

          echo "‚úÖ Backend Lambda deployed successfully"

      - name: Update Backend Lambda Environment Variables
        run: |
          # Create environment variables JSON file
          cat > /tmp/lambda-env.json <<EOF
          {
            "Variables": {
              "DATABASE_URL": "${{ secrets.DATABASE_URL }}",
              "LOG_LEVEL": "${{ secrets.LOG_LEVEL }}",
              "NODE_ENV": "production",
              "PORT": "${{ secrets.PORT }}",
              "SQS_QUEUE_URL": "${{ steps.get-infra.outputs.worker_queue_url }}"
            }
          }
          EOF

          # Update Lambda function environment variables with secrets
          aws lambda update-function-configuration \
            --function-name ${{ steps.get-infra.outputs.backend_lambda }} \
            --environment file:///tmp/lambda-env.json \
            --region ${{ env.AWS_REGION }} \
            --wait

          echo "‚úÖ Backend Lambda environment variables updated successfully"

      - name: Build Client
        working-directory: apps/client
        env:
          VITE_BACKEND_URL: ${{ steps.get-infra.outputs.api_url }}
        run: |
          bun install --frozen-lockfile
          bun run build

      - name: Deploy Client to S3 and CloudFront
        run: |
          # Get S3 bucket name from Pulumi
          BUCKET_NAME=$(bun x pulumi stack output bucketName -s client-prod 2>/dev/null || echo "")
          DIST_ID=$(bun x pulumi stack output distributionId -s client-prod 2>/dev/null || echo "")

          if [[ -z "$BUCKET_NAME" ]]; then
            echo "‚ùå Could not find S3 bucket. Is infrastructure deployed?"
            exit 1
          fi

          echo "üì§ Uploading to S3 bucket: ${BUCKET_NAME}"
          # Upload static assets with long cache
          aws s3 sync apps/client/dist/ s3://${BUCKET_NAME}/ \
            --region ${{ env.AWS_REGION }} \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html"

          # Upload HTML files with no cache
          aws s3 sync apps/client/dist/ s3://${BUCKET_NAME}/ \
            --region ${{ env.AWS_REGION }} \
            --delete \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html"

          # Invalidate CloudFront cache
          if [[ -n "$DIST_ID" ]] && [[ "$DIST_ID" != "None" ]]; then
            echo "üîÑ Invalidating CloudFront cache..."
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id ${DIST_ID} \
              --paths "/*" \
              --query 'Invalidation.Id' \
              --output text)
            echo "‚úÖ CloudFront invalidation created: ${INVALIDATION_ID}"
          fi

          echo "‚úÖ Client deployed successfully"
