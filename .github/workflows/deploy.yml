name: Deploy Code

on:
  push:
    branches:
      - master
      - staging
  workflow_dispatch:

env:
  AWS_REGION: eu-west-3

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/master' && 'production' || 'staging' }}
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set environment variables
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "env_name=production" >> $GITHUB_OUTPUT
            echo "docker_tag=prod" >> $GITHUB_OUTPUT
          else
            echo "env_name=staging" >> $GITHUB_OUTPUT
            echo "docker_tag=staging" >> $GITHUB_OUTPUT
          fi

      - name: Build Worker Docker Image
        run: |
          docker build -t worker-${{ steps.env.outputs.docker_tag }} -f .docker/Dockerfile.worker .

      - name: Push Worker Image to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ secrets.WORKER_ECR_REPO_URL }}
          docker tag worker-${{ steps.env.outputs.docker_tag }} ${{ secrets.WORKER_ECR_REPO_URL }}:${{ steps.env.outputs.docker_tag }}
          docker push ${{ secrets.WORKER_ECR_REPO_URL }}:${{ steps.env.outputs.docker_tag }}

      - name: Update Worker Lambda
        run: |
          aws lambda update-function-code \
            --function-name ${{ secrets.WORKER_LAMBDA_NAME }} \
            --image-uri ${{ secrets.WORKER_ECR_REPO_URL }}:${{ steps.env.outputs.docker_tag }} \
            --region ${{ env.AWS_REGION }} \
            --wait
          cat > /tmp/env.json <<EOF
          {"Variables":{"DATABASE_URL":"${{ secrets.DATABASE_URL }}","LOG_LEVEL":"${{ secrets.LOG_LEVEL }}","NODE_ENV":"${{ steps.env.outputs.env_name }}","WORKER_MODE":"lambda","SQS_QUEUE_URL":"${{ secrets.WORKER_QUEUE_URL }}"}}
          EOF
          aws lambda update-function-configuration \
            --function-name ${{ secrets.WORKER_LAMBDA_NAME }} \
            --environment file:///tmp/env.json \
            --region ${{ env.AWS_REGION }} \
            --wait

      - name: Build Backend Docker Image
        run: |
          docker build -t api-${{ steps.env.outputs.docker_tag }} -f .docker/Dockerfile.lambda .

      - name: Push Backend Image to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ secrets.BACKEND_ECR_REPO_URL }}
          docker tag api-${{ steps.env.outputs.docker_tag }} ${{ secrets.BACKEND_ECR_REPO_URL }}:${{ steps.env.outputs.docker_tag }}
          docker push ${{ secrets.BACKEND_ECR_REPO_URL }}:${{ steps.env.outputs.docker_tag }}

      - name: Update Backend Lambda
        run: |
          aws lambda update-function-code \
            --function-name ${{ secrets.BACKEND_LAMBDA_NAME }} \
            --image-uri ${{ secrets.BACKEND_ECR_REPO_URL }}:${{ steps.env.outputs.docker_tag }} \
            --region ${{ env.AWS_REGION }} \
            --wait
          cat > /tmp/env.json <<EOF
          {"Variables":{"DATABASE_URL":"${{ secrets.DATABASE_URL }}","LOG_LEVEL":"${{ secrets.LOG_LEVEL }}","NODE_ENV":"${{ steps.env.outputs.env_name }}","PORT":"${{ secrets.PORT }}","SQS_QUEUE_URL":"${{ secrets.WORKER_QUEUE_URL }}"}}
          EOF
          aws lambda update-function-configuration \
            --function-name ${{ secrets.BACKEND_LAMBDA_NAME }} \
            --environment file:///tmp/env.json \
            --region ${{ env.AWS_REGION }} \
            --wait

      - name: Build Client
        working-directory: apps/client
        env:
          VITE_BACKEND_URL: ${{ secrets.API_URL }}
        run: |
          bun install --frozen-lockfile
          bun run build

      - name: Deploy Client to S3
        run: |
          aws s3 sync apps/client/dist/ s3://${{ secrets.CLIENT_S3_BUCKET }}/ \
            --region ${{ env.AWS_REGION }} \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html"
          aws s3 sync apps/client/dist/ s3://${{ secrets.CLIENT_S3_BUCKET }}/ \
            --region ${{ env.AWS_REGION }} \
            --delete \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html"

      - name: Invalidate CloudFront Cache
        run: |
          if [[ -n "${{ secrets.CLIENT_CLOUDFRONT_DIST_ID }}" ]] && [[ "${{ secrets.CLIENT_CLOUDFRONT_DIST_ID }}" != "None" ]]; then
            aws cloudfront create-invalidation \
              --distribution-id ${{ secrets.CLIENT_CLOUDFRONT_DIST_ID }} \
              --paths "/*" \
              --query 'Invalidation.Id' \
              --output text
          fi
