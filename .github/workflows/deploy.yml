name: Deploy Code to Production

on:
  push:
    branches:
      - master
  workflow_dispatch:

env:
  NODE_ENV: production
  AWS_REGION: eu-west-3

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Infrastructure Outputs
        id: infra
        run: |
          set -e
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGION=${{ env.AWS_REGION }}
          
          # Worker ECR repo
          WORKER_REPO="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com/worker-prod"
          
          # Worker Lambda - find by name pattern
          WORKER_LAMBDA=$(aws lambda list-functions --region ${REGION} --query "Functions[?contains(FunctionName, 'worker-prod') && contains(FunctionName, 'lambda')].FunctionName" --output text | tr '\t' '\n' | head -n1)
          
          # Worker SQS queue - try exact name first, then search
          WORKER_QUEUE=$(aws sqs get-queue-url --region ${REGION} --queue-name worker-prod-queue --query 'QueueUrl' --output text 2>/dev/null || \
            aws sqs list-queues --region ${REGION} --query "QueueUrls[?contains(@, 'worker-prod-queue')]" --output text | tr '\t' '\n' | head -n1)
          
          # Backend ECR repo
          BACKEND_REPO="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com/api-prod"
          
          # Backend Lambda - find by name pattern
          BACKEND_LAMBDA=$(aws lambda list-functions --region ${REGION} --query "Functions[?contains(FunctionName, 'api-prod') && contains(FunctionName, 'apiLambda')].FunctionName" --output text | tr '\t' '\n' | head -n1)
          
          # Backend API Gateway - find by name pattern
          API_ID=$(aws apigatewayv2 get-apis --region ${REGION} --query "Items[?contains(Name, 'api-prod')].ApiId" --output text | tr '\t' '\n' | head -n1)
          API_URL="https://${API_ID}.execute-api.${REGION}.amazonaws.com"
          
          # Client S3 bucket - find by name pattern
          CLIENT_BUCKET=$(aws s3api list-buckets --query "Buckets[?contains(Name, 'client-prod')].Name" --output text | tr '\t' '\n' | head -n1)
          
          # Client CloudFront distribution - find by origin bucket
          CLIENT_DIST=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[0].DomainName=='${CLIENT_BUCKET}.s3.${REGION}.amazonaws.com' || Origins.Items[0].DomainName=='${CLIENT_BUCKET}.s3-website.${REGION}.amazonaws.com'].Id" --output text | tr '\t' '\n' | head -n1)
          
          echo "worker_repo=${WORKER_REPO}" >> $GITHUB_OUTPUT
          echo "worker_lambda=${WORKER_LAMBDA}" >> $GITHUB_OUTPUT
          echo "worker_queue=${WORKER_QUEUE}" >> $GITHUB_OUTPUT
          echo "backend_repo=${BACKEND_REPO}" >> $GITHUB_OUTPUT
          echo "backend_lambda=${BACKEND_LAMBDA}" >> $GITHUB_OUTPUT
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "client_bucket=${CLIENT_BUCKET}" >> $GITHUB_OUTPUT
          echo "client_dist=${CLIENT_DIST}" >> $GITHUB_OUTPUT

      - name: Build Worker Docker Image
        run: |
          docker build -t worker-prod -f .docker/Dockerfile.worker .

      - name: Push Worker Image to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ steps.infra.outputs.worker_repo }}
          docker tag worker-prod ${{ steps.infra.outputs.worker_repo }}:prod
          docker push ${{ steps.infra.outputs.worker_repo }}:prod

      - name: Update Worker Lambda
        run: |
          aws lambda update-function-code \
            --function-name ${{ steps.infra.outputs.worker_lambda }} \
            --image-uri ${{ steps.infra.outputs.worker_repo }}:prod \
            --region ${{ env.AWS_REGION }} \
            --wait
          cat > /tmp/env.json <<EOF
          {"Variables":{"DATABASE_URL":"${{ secrets.DATABASE_URL }}","LOG_LEVEL":"${{ secrets.LOG_LEVEL }}","NODE_ENV":"production","WORKER_MODE":"lambda","SQS_QUEUE_URL":"${{ steps.infra.outputs.worker_queue }}"}}
          EOF
          aws lambda update-function-configuration \
            --function-name ${{ steps.infra.outputs.worker_lambda }} \
            --environment file:///tmp/env.json \
            --region ${{ env.AWS_REGION }} \
            --wait

      - name: Build Backend Docker Image
        run: |
          docker build -t api-prod -f .docker/Dockerfile.lambda .

      - name: Push Backend Image to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ steps.infra.outputs.backend_repo }}
          docker tag api-prod ${{ steps.infra.outputs.backend_repo }}:prod
          docker push ${{ steps.infra.outputs.backend_repo }}:prod

      - name: Update Backend Lambda
        run: |
          aws lambda update-function-code \
            --function-name ${{ steps.infra.outputs.backend_lambda }} \
            --image-uri ${{ steps.infra.outputs.backend_repo }}:prod \
            --region ${{ env.AWS_REGION }} \
            --wait
          cat > /tmp/env.json <<EOF
          {"Variables":{"DATABASE_URL":"${{ secrets.DATABASE_URL }}","LOG_LEVEL":"${{ secrets.LOG_LEVEL }}","NODE_ENV":"production","PORT":"${{ secrets.PORT }}","SQS_QUEUE_URL":"${{ steps.infra.outputs.worker_queue }}"}}
          EOF
          aws lambda update-function-configuration \
            --function-name ${{ steps.infra.outputs.backend_lambda }} \
            --environment file:///tmp/env.json \
            --region ${{ env.AWS_REGION }} \
            --wait

      - name: Build Client
        working-directory: apps/client
        env:
          VITE_BACKEND_URL: ${{ steps.infra.outputs.api_url }}
        run: |
          bun install --frozen-lockfile
          bun run build

      - name: Deploy Client to S3
        run: |
          aws s3 sync apps/client/dist/ s3://${{ steps.infra.outputs.client_bucket }}/ \
            --region ${{ env.AWS_REGION }} \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html"
          aws s3 sync apps/client/dist/ s3://${{ steps.infra.outputs.client_bucket }}/ \
            --region ${{ env.AWS_REGION }} \
            --delete \
            --cache-control "public, max-age=0, must-revalidate" \
            --include "*.html"

      - name: Invalidate CloudFront Cache
        if: steps.infra.outputs.client_dist != '' && steps.infra.outputs.client_dist != 'None'
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ steps.infra.outputs.client_dist }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text
